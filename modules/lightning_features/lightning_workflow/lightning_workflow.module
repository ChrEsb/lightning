<?php

/**
 * @file
 * Provides workflow enhancements for Drupal.
 */

use Drupal\content_moderation\Plugin\WorkflowType\ContentModeration;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityPublishedInterface;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\lightning_core\Element;
use Drupal\lightning_core\Routing\RouteSubscriber;
use Drupal\lightning_workflow\Plugin\views\field\NodeBulkForm;
use Drupal\node\NodeTypeInterface;
use Drupal\views\ViewEntityInterface;
use Drupal\views\ViewExecutable;
use Drupal\workflows\Entity\Workflow;

/**
 * Implements hook_ENTITY_TYPE_insert().
 */
function lightning_workflow_node_type_insert(NodeTypeInterface $node_type) {
  // Don't do anything during a config sync.
  if (\Drupal::isConfigSyncing()) {
    return;
  }

  $workflow = $node_type->getThirdPartySetting('lightning_workflow', 'workflow');
  if (empty($workflow)) {
    return;
  }

  $workflow = Workflow::load($workflow);
  if (empty($workflow)) {
    return;
  }

  $plugin = $workflow->getTypePlugin();
  if ($plugin instanceof ContentModeration) {
    $configuration = $plugin->getConfiguration();
    $configuration['entity_types']['node'][] = $node_type->id();
    $plugin->setConfiguration($configuration);
    $workflow->save();
  }
}

/**
 * Implements hook_theme_registry_alter().
 */
function lightning_workflow_theme_registry_alter(array &$theme_registry) {
  foreach ($theme_registry as $hook => &$info) {
    if ($hook == 'field' || (isset($info['base hook']) && $info['base hook'] == 'field')) {
      // We wrap around Quick Edit's preprocess function, so it should not be
      // run directly.
      $info['preprocess functions'] = array_diff($info['preprocess functions'], ['quickedit_preprocess_field']);
    }
  }
}

/**
 * Implements template_preprocess_field().
 */
function lightning_workflow_preprocess_field(array &$variables) {
  if (\Drupal::moduleHandler()->moduleExists('quickedit')) {
    quickedit_preprocess_field($variables);

    /** @var \Drupal\Core\Entity\EntityInterface $entity */
    $entity = $variables['element']['#object'];

    if ($entity instanceof EntityPublishedInterface && $entity->isPublished() && RouteSubscriber::isViewing($entity)) {
      unset($variables['attributes']['data-quickedit-field-id']);
    }
  }
}

/**
 * Implements hook_module_implements_alter().
 */
function lightning_workflow_module_implements_alter(array &$implementations, $hook) {
  // We have to check for hook_node_view_alter() because of absolute insanity
  // in ModuleHandler::alter() and the way it determines the implementations of
  // 'secondary' alter hooks. It's weird logic that is pretty close to
  // inexplicable...but trust me, to wrap around quickedit_entity_view_alter(),
  // we need to alter the implementations of hook_node_view_alter(). Granted,
  // this will only work for nodes. If we want to do this for another entity
  // type, we'll have to check for its entity type-specific view_alter hook as
  // well.
  if ($hook == 'node_view_alter') {
    unset($implementations['quickedit']);
  }
}

/**
 * Implements hook_entity_view_alter().
 */
function lightning_workflow_entity_view_alter(array &$build, EntityInterface $entity, EntityViewDisplayInterface $display) {
  if (\Drupal::moduleHandler()->moduleExists('quickedit')) {
    quickedit_entity_view_alter($build, $entity, $display);

    if ($entity instanceof EntityPublishedInterface && $entity->isPublished() && RouteSubscriber::isViewing($entity)) {
      unset($build['#attributes']['data-quickedit-entity-id']);
    }
  }
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 */
function lightning_workflow_view_presave(ViewEntityInterface $view) {
  // Don't do anything during config sync.
  if (\Drupal::isConfigSyncing()) {
    return;
  }
  elseif ($view->id() == 'content' && $view->isNew()) {
    $display = &$view->getDisplay('default');
    $display_options = &$display['display_options'];

    // Add a relationship to the latest revision.
    $display_options['relationships']['latest_revision__node'] = unserialize('a:8:{s:2:"id";s:21:"latest_revision__node";s:5:"table";s:26:"workbench_revision_tracker";s:5:"field";s:21:"latest_revision__node";s:12:"relationship";s:4:"none";s:10:"group_type";s:5:"group";s:11:"admin_label";s:15:"latest revision";s:8:"required";b:0;s:9:"plugin_id";s:8:"standard";}');

    // Add the forward revision indicator.
    $display_options['fields']['forward_revision_exists'] = unserialize('a:23:{s:2:"id";s:23:"forward_revision_exists";s:5:"table";s:15:"node_field_data";s:5:"field";s:23:"forward_revision_exists";s:12:"relationship";s:4:"none";s:10:"group_type";s:5:"group";s:11:"admin_label";s:0:"";s:5:"label";s:21:"Has unpublished edits";s:7:"exclude";b:0;s:5:"alter";a:26:{s:10:"alter_text";b:0;s:4:"text";s:0:"";s:9:"make_link";b:0;s:4:"path";s:0:"";s:8:"absolute";b:0;s:8:"external";b:0;s:14:"replace_spaces";b:0;s:9:"path_case";s:4:"none";s:15:"trim_whitespace";b:0;s:3:"alt";s:0:"";s:3:"rel";s:0:"";s:10:"link_class";s:0:"";s:6:"prefix";s:0:"";s:6:"suffix";s:0:"";s:6:"target";s:0:"";s:5:"nl2br";b:0;s:10:"max_length";i:0;s:13:"word_boundary";b:1;s:8:"ellipsis";b:1;s:9:"more_link";b:0;s:14:"more_link_text";s:0:"";s:14:"more_link_path";s:0:"";s:10:"strip_tags";b:0;s:4:"trim";b:0;s:13:"preserve_tags";s:0:"";s:4:"html";b:0;}s:12:"element_type";s:0:"";s:13:"element_class";s:0:"";s:18:"element_label_type";s:0:"";s:19:"element_label_class";s:0:"";s:19:"element_label_colon";b:1;s:20:"element_wrapper_type";s:0:"";s:21:"element_wrapper_class";s:0:"";s:23:"element_default_classes";b:1;s:5:"empty";s:0:"";s:10:"hide_empty";b:0;s:10:"empty_zero";b:0;s:16:"hide_alter_empty";b:1;s:11:"entity_type";s:4:"node";s:9:"plugin_id";s:23:"forward_revision_exists";}');

    Element::toTail($display_options['fields'], 'operations');
  }
}

/**
 * Implements hook_modules_installed().
 */
function lightning_workflow_modules_installed(array $modules) {
  // Don't do anything during config sync.
  if (\Drupal::isConfigSyncing()) {
    return;
  }
  elseif (in_array('lightning_roles', $modules)) {
    \Drupal::service('lightning.content_roles')
      ->grantPermissions('creator', [
        'view any unpublished content',
        'use editorial transition create_new_draft',
        'use editorial transition review',
        'view latest version',
      ])
      ->grantPermissions('reviewer', [
        'use editorial transition publish',
        'use editorial transition review',
        'use editorial transition archive',
        'view moderation states',
      ]);
  }
}

/**
 * Implements hook_views_data().
 */
function lightning_workflow_views_data() {
  return \Drupal::service('lightning_workflow.views_data')->getAll();
}

/**
 * Implements hook_views_plugins_field_alter().
 */
function lightning_workflow_views_plugins_field_alter(array &$plugins) {
  if (isset($plugins['node_bulk_form'])) {
    $plugins['node_bulk_form']['class'] = NodeBulkForm::class;
  }
}

/**
 * Implements hook_views_pre_render().
 */
function lightning_workflow_views_pre_render(ViewExecutable $view) {
  if ($view->storage->id() == 'moderation_history') {
    foreach ($view->result as $index => $row) {
      $entity = $row->_entity;

      if (empty($previous) || $previous->moderation_state->target_id != $entity->moderation_state->target_id) {
        $previous = $entity;
      }
      else {
        unset($view->result[$index]);
        $view->total_rows--;
      }
    }
  }
}
